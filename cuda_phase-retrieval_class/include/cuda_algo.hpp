#include <pybind11/numpy.h>
#include <pybind11/stl.h>
#include <cufft.h>
#include <cuComplex.h>
#include <curand.h>
#include <curand_kernel.h>
#include <cstdio>
#include <iostream>
#include <complex>

#define PI 3.1415926535897932384626433
#define CUDA_CHECK(call) {cudaError_t error = call; if(error!=cudaSuccess){printf("<%s>:%i ",__FILE__,__LINE__); printf("[CUDA] Error: %s\n", cudaGetErrorString(error));}}

__device__ cufftDoubleComplex gpu_exp(cufftDoubleComplex complex_number);
__device__ cufftDoubleComplex normalize(cufftDoubleComplex complex_number, int size);
__device__ cufftDoubleComplex get_complex(double real_number);
__device__ double get_real(cufftDoubleComplex complex_number);
__global__ void init_random(double seed, curandState_t *states, int dimension);
__global__ void get_complex_array(double *real_array, cufftDoubleComplex *complex_array, int dimension);
__global__ void get_absolute_array(cufftDoubleComplex *complex_array, double *real_array , int dimension);
__global__ void normalize_array(cufftDoubleComplex *ptrImg, cufftDoubleComplex *ptrRes, int dimension);
template<typename TInputData, typename TOutputData> TOutputData * convertToCUFFT(TInputData * ptr);
template<> cufftDoubleComplex *convertToCUFFT(std::complex<double> * ptr);
void CUFFT_CHECK(cufftResult cufft_process);
int get_number_of_cuda_sm();


/**
 * \brief Calculate exponential of a double complex in GPU
 * \param complex_number A single double complex number, implemented using CUFFT library
 * \return Exponential value of the complex number
 */
__device__ cufftDoubleComplex gpu_exp(cufftDoubleComplex complex_number)
{
    cufftDoubleComplex result;
    float s, c;
    float e = expf(complex_number.x);
    sincosf(complex_number.y, &s, &c);
    result.x = c * e;
    result.y = s * e;
    return result;
}

/**
* \brief Normalize every result elements of after doing CUFFT_INVERSE
* \param complex_number A single double complex number, implemented using CUFFT library
* \param dimension Size of all arrays
* \return normalized complex number
*/
__device__ cufftDoubleComplex normalize(cufftDoubleComplex complex_number, int dimension)
{
    cufftDoubleComplex normalized_complex_number;
    normalized_complex_number.x = complex_number.x / static_cast<double>(dimension);
    normalized_complex_number.y = complex_number.y / static_cast<double>(dimension);
    
    return normalized_complex_number;
}

/**
* \brief Convert real number to CUFFT complex number, using 0 as imaginary part
* \param real_number A single double value
* \return Complex version of the double value, implemented using CUFFT
*/
__device__ cufftDoubleComplex get_complex(double real_number)
{
    cufftDoubleComplex complex_number;
    complex_number.x = real_number;
    complex_number.y = 0;

    return complex_number;
}

/**
* \brief Get real number part of a CUFFT complex number
* \param complex_number A single double complex number, implemented using CUFFT library
* \return real number part of the complex number
*/
__device__ double get_real(cufftDoubleComplex complex_number)
{
    return complex_number.x;
}

/**
* \brief Create states for random values
* \param seed Current time in seconds (seed for randomizer)
* \param states Random states generated by for CURAND
* \param dimension Size of all arrays
*/
__global__ void init_random(double seed, curandState_t *states, int dimension)
{
    for (int idx = blockIdx.x * blockDim.x + threadIdx.x; idx < dimension; idx += blockDim.x * gridDim.x) 
    { 
        curand_init(seed, idx, 0, &states[idx]);
    }
}

/**
* \brief Convert array of real number into array of complex number
* \param real_array Array of double real number
* \param complex_array Array of double complex number, implemented using CUFFT library
* \param dimension Size of all arrays
*/
__global__ void get_complex_array(double *real_array, cufftDoubleComplex *complex_array, int dimension)
{
  for (int idx = blockIdx.x * blockDim.x + threadIdx.x; idx < dimension; idx += blockDim.x * gridDim.x)  
    {
        cufftDoubleComplex complex_number;
        complex_number.x = real_array[idx];
        complex_number.y = 0;
        complex_array[idx] = complex_number;
    }
}

/**
* \brief Get array of absolute value from array of complex number
* \param complex_array Array of double complex number, implemented using CUFFT library
* \param real_array Array of absolute value of the complex number
* \param dimension Size of all arrays
*/
__global__ void get_absolute_array(cufftDoubleComplex *complex_array, double *real_array , int dimension)
{
    for (int idx = blockIdx.x * blockDim.x + threadIdx.x; idx < dimension; idx += blockDim.x * gridDim.x)  
    {
        real_array[idx] = cuCabs(complex_array[idx]);
    }
}

/**
* \brief CUFFT error checking
* \param cufft_process Result of a CUFFT operation
*/ 
void CUFFT_CHECK(cufftResult cufft_process)
{
    if(cufft_process != CUFFT_SUCCESS) std::cout<<cufft_process<<std::endl;
}

/**
* \brief Reinterpret a complex pointer from standard complex to CUDA FFT
* \param ptr a standard complex number
* \return CUDA FFT version of the standard complex number
*/ 

template<>
cufftDoubleComplex *convertToCUFFT(std::complex<double> * ptr)
{  
    return reinterpret_cast<cufftDoubleComplex *>(ptr);
}

/**
* \brief Generate a cupy array with 0 as the values
* \param shape vector representing dimension and size
* \return python object, which is a cupy array
*/

//Normalize array of complex number (results of CUFFT INVERSE)
__global__ void normalize_array(cufftDoubleComplex *ptrImg, cufftDoubleComplex *ptrRes, int dimension)
{
    for (int idx = blockIdx.x * blockDim.x + threadIdx.x; idx < dimension; idx += blockDim.x * gridDim.x)
    {
        ptrRes[idx].x = ptrImg[idx].x / static_cast<double>(dimension);
        ptrRes[idx].y = ptrImg[idx].y / static_cast<double>(dimension);
    }
}

/**
* \brief Set number of Streaming Multiprocessor for CUDA Kernel
*/ 
int get_number_of_cuda_sm()
{
    int devId, numSMs;
    cudaGetDevice(&devId);
    cudaDeviceGetAttribute( &numSMs, cudaDevAttrMultiProcessorCount, devId);
    return numSMs;
}